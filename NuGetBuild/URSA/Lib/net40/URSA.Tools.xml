<?xml version="1.0"?>
<doc>
    <assembly>
        <name>URSA.Tools</name>
    </assembly>
    <members>
        <member name="T:System.AppDomainExtensions">
            <summary>Provides useful <see cref="T:System.AppDomain"/> extension methods.</summary>
        </member>
        <member name="M:System.AppDomainExtensions.GetPrimaryAssemblyDirectory(System.AppDomain)">
            <summary>Gets a primary path storing assemblies for given application domain.</summary> 
            <param name="domain">Application domain for which the path is being determined.</param> 
            <returns>Primary place where assemblies for given application domain are stored.</returns> 
        </member>
        <member name="T:System.Collections.Generic.DictionaryExtensions">
            <summary>Provides useful <see cref="T:System.Collections.Generic.IDictionary`2"/> extensions.</summary>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.GetOrCreate``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>Gets the element under the <paramref name="key" />. If the item doesn't exist, it uses <paramref name="defaultValue" /> to create it.</summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key.</param>
            <param name="defaultValue">The default value.</param>
            <returns>Value under <paramref name="key" />.</returns>
        </member>
        <member name="T:System.IO.UnclosableStream">
            <summary>Wraps streams so they cannot be closed.</summary>
        </member>
        <member name="M:System.IO.UnclosableStream.#ctor(System.IO.Stream)">
            <summary>Initializes a new instance of the <see cref="T:System.IO.UnclosableStream"/> class.</summary>
            <param name="stream">Stream to be wrapped.</param>
        </member>
        <member name="M:System.IO.UnclosableStream.Dispose">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Close">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.CreateObjRef(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.EndRead(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.EndWrite(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.InitializeLifetimeService">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.ReadByte">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:System.IO.UnclosableStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.Length">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.Position">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.CanTimeout">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.ReadTimeout">
            <inheritdoc />
        </member>
        <member name="P:System.IO.UnclosableStream.WriteTimeout">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>Provides useful <see cref="T:System.Collections.Generic.IEnumerable`1"/> extension methods.</summary>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.ForEach(System.Collections.IEnumerable,System.Action{System.Object})">
            <summary>Applies the given <paramref name="action" /> on each of the <paramref name="items" />.</summary>
            <param name="items">Items to be iterated through.</param>
            <param name="action">Action to be applied.</param>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.ForEach(System.Collections.IEnumerable,System.Action{System.Object,System.Int32})">
            <summary>Applies the given <paramref name="action" /> on each of the <paramref name="items" />.</summary>
            <param name="items">Items to be iterated through.</param>
            <param name="action">Action to be applied.</param>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Applies the given <paramref name="action" /> on each of the <paramref name="items" />.</summary>
            <typeparam name="T">Type of items in the enumeration.</typeparam>
            <param name="items">Items to be iterated through.</param>
            <param name="action">Action to be applied.</param>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>Applies the given <paramref name="action" /> on each of the <paramref name="items" />.</summary>
            <typeparam name="T">Type of items in the enumeration.</typeparam>
            <param name="items">Items to be iterated through.</param>
            <param name="action">Action to be applied.</param>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.AddUnique``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>Adds a new item to the collection if it does not exist.</summary>
            <typeparam name="T">Type of items in the collection.</typeparam>
            <param name="items">Collection to add to.</param>
            <param name="newItem">Item to be added.</param>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.AddUnique``1(System.Collections.Generic.ICollection{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Adds a new item to the collection if it does not exist.</summary>
            <typeparam name="T">Type of items in the collection.</typeparam>
            <param name="items">Collection to add to.</param>
            <param name="newItem">Item to be added.</param>
            <param name="comparer">Comparer to be used when comparing items.</param>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Adds a range of items to the collection.</summary>
            <typeparam name="T">Type of items in the collection.</typeparam>
            <param name="items">Collection to add to.</param>
            <param name="newItems">Items to be added.</param>
        </member>
        <member name="T:System.LiteralUriComparer">
            <summary>Compares <see cref="T:System.Uri"/>s literally.</summary>
        </member>
        <member name="F:System.LiteralUriComparer.Instance">
            <summary>Defines an singleton instance of the <see cref="T:System.LiteralUriComparer"/>.</summary>
        </member>
        <member name="M:System.LiteralUriComparer.Equals(System.Uri,System.Uri)">
            <inheritdoc />
        </member>
        <member name="M:System.LiteralUriComparer.GetHashCode(System.Uri)">
            <inheritdoc />
        </member>
        <member name="T:System.Reflection.AssemblyExtensions">
            <summary>Provides useful <see cref="T:System.Reflection.Assembly"/> related extension methods.</summary>
        </member>
        <member name="M:System.Reflection.AssemblyExtensions.FindEnumValue(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.String)">
            <summary>Searches types in assemblies for an enumeration value that has string representation of the given <paramref name="value"/>.</summary>
            <remarks>This method uses <see cref="P:System.StringComparer.OrdinalIgnoreCase"/> to compare string representations.</remarks>
            <param name="assemblies">Assemblies to be searched through.</param>
            <param name="value">Value to be searched for.</param>
            <returns>Instance of the enumeration value if matched; otherwise <b>null</b>.</returns>
        </member>
        <member name="T:System.StringExtensions">
            <summary>Provides useful string extension methods.</summary>
        </member>
        <member name="M:System.StringExtensions.ToDisplayString(System.String)">
            <summary>Converts a camelCase or PascalCase strings to corresponding camel Case or Pascal Case strings.</summary>
            <param name="pascalOrCamelCaseString">String to be converted.</param>
            <returns>Converted string with spaces.</returns>
        </member>
        <member name="M:System.StringExtensions.Indent(System.String,System.Int32)">
            <summary>Indents the specified text.</summary>
            <param name="text">The text to be indented.</param>
            <param name="indentation">The indentation.</param>
            <returns>Text with indented new lines.</returns>
        </member>
        <member name="M:System.StringExtensions.ToLowerCamelCase(System.String)">
            <summary>Converts a given text value into a lowerCamelCase string.</summary>
            <param name="value">Value to be converter</param>
            <returns>Text converted to lowerCamelCase or <b>null</b> if the input <paramref name="value" /> was also <b>null</b>.</returns>
        </member>
        <member name="M:System.StringExtensions.ToUpperCamelCase(System.String)">
            <summary>Converts a given text value into a UpperCamelCase string (aka. Pascal case).</summary>
            <param name="value">Value to be converter</param>
            <returns>Text converted to UpperCamelCase or <b>null</b> if the input <paramref name="value" /> was also <b>null</b>.</returns>
        </member>
        <member name="T:System.Reflection.TypeExtensions">
            <summary>Provides useful <see cref="T:System.Type"/> extensions.</summary>
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsList(System.Type)">
            <summary>Checks if a given type is of either type <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <param name="type">Type to check.</param>
            <returns><b>true</b> if the type implements a proper interface; otherwise <b>false</b>.</returns>
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsGenericList(System.Type)">
            <summary>Checks if a given type is of type <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <param name="type">Type to check.</param>
            <returns><b>true</b> if the type implements a proper interface; otherwise <b>false</b>.</returns>
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsCollection(System.Type)">
            <summary>Checks if a given type is of either type <see cref="T:System.Collections.ICollection"/> or <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="type">Type to check.</param>
            <returns><b>true</b> if the type implements a proper interface; otherwise <b>false</b>.</returns>
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsGenericCollection(System.Type)">
            <summary>Checks if a given type is of type <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="type">Type to check.</param>
            <returns><b>true</b> if the type implements a proper interface; otherwise <b>false</b>.</returns>
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsEnumerable(System.Type)">
            <summary>Checks if the type can be assigned to the <see cref="T:System.Collections.IEnumerable"/> interface.</summary> 
            <remarks>This method will return false for type <see cref="T:System.String"/>.</remarks> 
            <param name="type">Type to be checked.</param> 
            <returns><b>true</b> if the type is <see cref="T:System.Array"/> or is assignable to <see cref="T:System.Collections.IEnumerable"/> (except <see cref="T:System.String"/>); otherwise <b>false</b>.</returns> 
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsGenericEnumerable(System.Type)">
            <summary>Checks if a given type is of type <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <param name="type">Type to check.</param>
            <returns><b>true</b> if the type implements a proper interface; otherwise <b>false</b>.</returns>
        </member>
        <member name="M:System.Reflection.TypeExtensions.GetItemType(System.Type)">
            <summary>Gets the item type of the collection type or the type itself.</summary>
            <param name="type">Type for which find the item type.</param>
            <returns><see cref="T:System.Type"/> being the item of the collection or the <paramref name="type"/> itself.</returns>
        </member>
        <member name="M:System.Reflection.TypeExtensions.MakeInstance(System.Collections.Generic.IEnumerable{System.Object},System.Type,System.Type)">
            <summary>Creates an instance of the <paramref name="targetType" /> from an enumeration of objects.</summary>
            <param name="values">Objects to feed the new instance.</param>
            <param name="targetType">Target type of the instance.</param>
            <param name="itemType">Optional collection item type.</param>
            <returns>Instance of the <paramref name="targetType" />.</returns>
        </member>
        <member name="T:System.UriExtensions">
            <summary>Provides useful <see cref="T:System.Uri"/> extension methods.</summary>
        </member>
        <member name="M:System.UriExtensions.ToRelativeUri(System.Uri)">
            <summary>Converts a given uri to a relative one.</summary>
            <param name="uri">Uri to be converted.</param>
            <returns>Relative <see cref="T:System.Uri"/> if the given <paramref name="uri"/> is absolute; otherwise <paramref name="uri"/>.</returns>
        </member>
        <member name="M:System.UriExtensions.Combine(System.Uri,System.Uri)">
            <summary>Combines two <see cref="T:System.Uri"/>s altogether, without checking if the base one is an absolute uri.</summary>
            <param name="uri">Relative uri to be appended.</param>
            <param name="baseUri">Base uri.</param>
            <returns><see cref="T:System.Uri"/> being a combination of the <paramref name="baseUri"/> and <paramref name="uri"/>.</returns>
        </member>
        <member name="M:System.UriExtensions.AddFragment(System.Uri,System.String)">
            <summary>Adds a fragment to given uri.</summary>
            <remarks>If the uri already has a fragment, it will be converted to segment.</remarks>
            <param name="uri">Uri to add fragment to.</param>
            <param name="fragment">Fragment to be added.</param>
            <returns><see cref="T:System.Uri"/> with fragment added.</returns>
        </member>
        <member name="M:System.UriExtensions.AddName(System.Uri,System.String)">
            <summary>Adds a name to given URN.</summary>
            <remarks>Appended name will start with dot (.).</remarks>
            <param name="uri">Uri to add name to.</param>
            <param name="name">Name to be added.</param>
            <returns><see cref="T:System.Uri"/> with name added.</returns>
        </member>
    </members>
</doc>
