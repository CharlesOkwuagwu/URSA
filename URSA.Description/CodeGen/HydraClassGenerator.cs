using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using RomanticWeb;
using RomanticWeb.Entities;
using URSA.Web;
using URSA.Web.Description.Http;
using URSA.Web.Http;
using URSA.Web.Http.Description.CodeGen;
using URSA.Web.Http.Description.Hydra;
using URSA.Web.Http.Description.Model;

namespace URSA.CodeGen
{
    /// <summary>Provides a basic implementation of the <see cref="IClassGenerator" />.</summary>
    public class HydraClassGenerator : IClassGenerator
    {
        private const string ClassTemplate =
            @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a URSA HTTP client proxy generation tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Dynamic;
using URSA.Web.Http;

namespace {0}
{{
    public class {1} : Client
    {{
        public {1}(Uri baseUri) : base(baseUri)
        {{
        }}{2}{3}{4}
    }}
}}";

        private const string NestedClassTemplate =
            @"

        public class {0}
        {{
{1}
        }}";

        private const string PropertyTemplate =
            @"

        public {3}.{4} {0} {{{1}{2}}}";

        private const string OperationTemplate =
            @"

        public{0} {1} {2}({3})
        {{
            " + ArgumentsTemplate + @"
{6}            Call(Verb.{4}, ""{5}"", uriArguments{7});
        }}";

        private const string ArgumentsTemplate = "dynamic uriArguments = new ExpandoObject();";

        private static readonly IDictionary<IResource, string> Namespaces = new ConcurrentDictionary<IResource, string>();
        private static readonly IDictionary<IResource, string> Names = new ConcurrentDictionary<IResource, string>();

        private readonly IEnumerable<IUriParser> _uriParsers;

        /// <summary>Initializes a new instance of the <see cref="HydraClassGenerator"/> class.</summary>
        /// <param name="uriParsers">The URI parsers.</param>
        public HydraClassGenerator(IEnumerable<IUriParser> uriParsers)
        {
            if (uriParsers == null)
            {
                throw new ArgumentNullException("uriParsers");
            }

            _uriParsers = uriParsers;
        }

        /// <inheritdoc />
        public string CreateCode(IClass supportedClass)
        {
            var includes = new StringBuilder(256);
            var properties = AnalyzeProperties(supportedClass);
            var operations = AnalyzeOperations(supportedClass, includes);
            return String.Format(ClassTemplate, CreateNamespace(supportedClass), CreateName(supportedClass), properties, operations, includes);
        }

        /// <inheritdoc />
        public string CreateNamespace(IResource resource)
        {
            string result;
            if (Namespaces.TryGetValue(resource, out result))
            {
                return result;
            }

            ParseUri(resource);
            return Namespaces[resource];
        }

        /// <inheritdoc />
        public string CreateName(IResource resource)
        {
            string result;
            if (Names.TryGetValue(resource, out result))
            {
                return result;
            }

            ParseUri(resource);
            return Names[resource];
        }

        /// <inheritdoc />
        private string CreateName(IClass @class)
        {
            return (!String.IsNullOrEmpty(@class.Label) ? @class.Label : CreateName((IResource)@class));
        }

        /// <inheritdoc />
        private string CreateName(IOperation operation, string method)
        {
            string result = operation.Label;
            if (operation.Method.Count > 1)
            {
                result = ControllerDescriptionBuilder<IController>.PopularNameMappings
                    .Where(item => item.Value.ToString() == method).Select(item => item.Key).FirstOrDefault() ?? method.ToUpperCamelCase();
            }

            if (String.IsNullOrEmpty(result))
            {
                result = CreateName((IResource)operation);
            }

            return result;
        }

        private void ParseUri(IResource resource)
        {
            var uriParser = (from parser in _uriParsers
                             orderby parser.IsApplicable(resource.Id.Uri) descending 
                             select parser).FirstOrDefault();

            if (uriParser == null)
            {
                throw new InvalidOperationException(String.Format("Cannot find a suitable parser for resource uri '{0}'.", resource.Id.Uri));
            }

            string @namespace;
            Names[resource] = uriParser.Parse(resource.Id.Uri, out @namespace);
            Namespaces[resource] = @namespace;
        }

        private string AnalyzeProperties(IClass supportedClass)
        {
            var properties = new StringBuilder(512);
            foreach (var property in supportedClass.SupportedProperties)
            {
                var propertyTypeNamespace = "System";
                var propertyTypeName = "Object";
                if (property.Property.Range.Any())
                {
                    var propertyType = property.Property.Range.First().AsEntity<IResource>();
                    propertyTypeNamespace = CreateNamespace(propertyType);
                    propertyTypeName = CreateName(propertyType);
                }

                properties.AppendFormat(
                    PropertyTemplate, 
                    property.Property.Label,
                    property.WriteOnly ? String.Empty : " get" + (property.ReadOnly ? " " : String.Empty) + ";", 
                    property.ReadOnly ? String.Empty : " set; ",
                    propertyTypeNamespace,
                    propertyTypeName);
            }

            return properties.ToString();
        }

        private string AnalyzeOperations(IClass supportedClass, StringBuilder includes)
        {
            var operations = new StringBuilder(1024);
            bool isTemplate = false;
            var supportedOperations = from quad in supportedClass.Context.Store.Quads.ToList()
                                      where (quad.Subject.IsUri) && (AbsoluteUriComparer.Default.Equals(quad.Subject.Uri, supportedClass.Id.Uri)) &&
                                            (quad.Object.IsUri) && (quad.Predicate.IsUri) && (!(isTemplate = false)) &&
                                            ((quad.Predicate.Uri.ToString() == HydraUriParser.HyDrA + "supportedOperation") ||
                                             (isTemplate = quad.PredicateIs(supportedClass.Context, new Uri(HydraUriParser.HyDrA + "IriTemplate"))))
                                      select new
                                      {
                                          Id = new EntityId(quad.Object.Uri),
                                          Template = (isTemplate ? supportedClass.Context.Load<IIriTemplate>(new EntityId(quad.Predicate.Uri)) : null)
                                      };
            foreach (var operationDescriptor in supportedOperations)
            {
                AnalyzeOperation(supportedClass, supportedClass.Context.Load<IOperation>(operationDescriptor.Id), operationDescriptor.Template, operations, includes);
            }

            return operations.ToString();
        }

        private void AnalyzeOperation(IClass supportedClass, IOperation operation, IIriTemplate template, StringBuilder operations, StringBuilder includes)
        {
            foreach (var method in operation.Method)
            {
                var bodyArguments = new StringBuilder(256);
                var uriArguments = new StringBuilder(256);
                var parameters = new StringBuilder(256);
                var returns = "void";
                var operationName = CreateName(operation, method);
                var uri = operation.Id.ToString();
                if (template != null)
                {
                    uri = template.Template;
                    AnalyzeTemplate(template.Mappings, parameters, uriArguments);
                }

                AnalyzeBody(operation.Expects, parameters, bodyArguments);
                if (parameters.Length > 2)
                {
                    parameters.Remove(parameters.Length - 2, 2);
                }

                if (operation.Returns.Any())
                {
                    returns = AnalyzeResult(operationName, operation.Returns, includes);
                }

                var isStatic = ((operation.Expects.Any(expected => expected == supportedClass)) && (method == "POST") ? " static" : String.Empty);
                operations.AppendFormat(OperationTemplate, isStatic, returns, operationName, parameters, method, uri, uriArguments, bodyArguments);
            }
        }

        private void AnalyzeTemplate(IEnumerable<IIriTemplateMapping> mappings, StringBuilder parameters, StringBuilder uriArguments)
        {
            foreach (var mapping in mappings)
            {
                var variableName = mapping.Variable.ToLowerCamelCase();
                IResource expected = null;
                if ((mapping.Property != null) && (mapping.Property.Range.Any()))
                {
                    expected = mapping.Property.Range.First().AsEntity<IResource>();
                }

                parameters.AppendFormat(
                    "{0}.{1} {2}, ",
                    (expected != null ? CreateNamespace(expected) : "System"),
                    (expected != null ? CreateName(expected) : "Object"),
                    variableName);
                uriArguments.AppendFormat("            uriArguments.{0} = {0};{1}", variableName, Environment.NewLine);
            }
        }

        private void AnalyzeBody(IEnumerable<IClass> expects, StringBuilder parameters, StringBuilder bodyArguments)
        {
            foreach (var expected in expects)
            {
                string variableName = expected.Label.ToLowerCamelCase();
                parameters.AppendFormat("{0}.{1} {2}, ", CreateNamespace(expected), CreateName(expected), variableName);
                bodyArguments.AppendFormat(", {0}", variableName);
            }
        }

        private string AnalyzeResult(string operationName, ICollection<IClass> returns, StringBuilder includes)
        {
            string result = null;
            if (returns.Count > 1)
            {
                result = String.Format("{0}Result", operationName);
                if (includes.ToString().IndexOf(result) != -1)
                {
                    return result;
                }

                var properties = new StringBuilder(256);
                foreach (var returned in returns)
                {
                    var name = CreateName(returned);
                    var @namespace = CreateNamespace(returned);
                    properties.AppendFormat(PropertyTemplate, name, " get;", String.Empty, @namespace, name);
                }

                includes.AppendFormat(NestedClassTemplate, result, properties);
            }
            else
            {
                var returned = returns.First();
                result = CreateName(returned);
                result = String.Format("{0}.{1}", CreateNamespace(returned), result);
            }

            return result;
        }
    }
}